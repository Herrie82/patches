diff --git a/usr/palm/frameworks/foundations/submission/104/javascript/comms/ajaxcall.js b/usr/palm/frameworks/foundations/submission/104/javascript/comms/ajaxcall.js
index 352618e..3eaeef3 100644
--- a/usr/palm/frameworks/foundations/submission/104/javascript/comms/ajaxcall.js
+++ b/usr/palm/frameworks/foundations/submission/104/javascript/comms/ajaxcall.js
@@ -361,7 +361,7 @@ var AjaxCall =
 			 */
 			var parsed = urlModule.parse(url);
 			var secure = (parsed.protocol === 'https:');
-			var port = (secure) ? 443 : 80;
+			var port = parseInt(parsed.port) || ((secure) ? 443 : 80);
 			
 			// console.log("SECURE="+secure);
 			// console.log("parsed = "+JSON.stringify(parsed));
@@ -428,7 +428,15 @@ var AjaxCall =
 				future._response = response;
 				local_result.status = response.statusCode;
 				local_result.getResponseHeader = function(name) {
-					return response.headers[name.toLowerCase()];
+					var lowerCaseName = name.toLowerCase();
+					if (lowerCaseName === 'set-cookie' && (Object.prototype.toString.call(response.headers['set-cookie']) === '[object Array]')) {
+						// set-cookie headers returned
+						// as an array so convert to
+						// comma-separated string
+						return response.headers['set-cookie'].join(', ');
+					} else {
+						return response.headers[lowerCaseName];
+					}
 				};
 				local_result.getAllResponseHeaders = function(name) {
 					if (!local_result.allHeaders) {
@@ -466,14 +474,23 @@ var AjaxCall =
 					future.exception = Err.create(error.errno, "httpResponse error " + error.message);
 				});
 				
-				response.addListener('end', function requestDone() {
+				var done = false;
+
+				function requestDone() {
+					if (done) return;
+					
+					done = true;
+
 					try {
 						local_result.responseJSON = JSON.parse(local_result.responseText);
 					} catch (parseError) {
 						//ignore errors while parsing the response as JSON - it must not be a JSON response
 					}
 					future.result = local_result;
-				});
+				}
+				
+				response.addListener('end', requestDone);
+				response.addListener('close', requestDone);
 			});
 			
 			// console.log("Body (" + bodyEncoding + ", " + headers["Content-Length"] + "): " + body);
diff --git a/usr/palm/frameworks/foundations/submission/104/javascript/control/activity.js b/usr/palm/frameworks/foundations/submission/104/javascript/control/activity.js
index 9577b4d..24787c7 100644
--- a/usr/palm/frameworks/foundations/submission/104/javascript/control/activity.js
+++ b/usr/palm/frameworks/foundations/submission/104/javascript/control/activity.js
@@ -273,6 +273,13 @@ Activity.prototype = {
 		return this;
 	},
 
+	setMetadata: function(data)
+	{
+		this._trace("setMetadata", arguments);
+		this._activity.metadata = data;
+		return this;
+	},
+
 	onEvent: function(callback)
 	{
 		this._trace("onEvent", arguments);
diff --git a/usr/palm/frameworks/mojoservice.transport.sync/submission/77/javascript/commands/synccommand.js b/usr/palm/frameworks/mojoservice.transport.sync/submission/77/javascript/commands/synccommand.js
index 87b6e88..9bcb10d 100644
--- a/usr/palm/frameworks/mojoservice.transport.sync/submission/77/javascript/commands/synccommand.js
+++ b/usr/palm/frameworks/mojoservice.transport.sync/submission/77/javascript/commands/synccommand.js
@@ -115,7 +115,20 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 	 */
 	getCapabilityProviderId: function() {
 	},
+	
+	/* 
+	 * Return the number of retries to attempt when a sync error occurs
+	 */
+	getMaxSyncRetries: function() {
+		return 3;
+	},
 
+	/* 
+	 * Return the number of retries to attempt when a sync error occurs
+	 */
+	getSyncRetryInterval: function(retriesSoFar) {
+		return "5m";
+	},
 	preSaveModify: function() {
 		Utils.debug("synccommand: preSaveModify()");
 		return new Future([]);
@@ -125,6 +138,288 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 		Utils.debug("synccomand: postPutRemoteModify()");
 		return new Future([]);
 	},
+	
+	getTweakedInterval: function(interval){
+		var serviceName = this.controller.service.name;
+		if(this.useTweaksReq && this.advSyncReq && this.advSyncReq.onoff === true){
+			if(serviceName.indexOf("calendar") !== -1 || (serviceName.indexOf("contacts") !== -1 && this.advSyncReq.contacts === true) ){
+				interval = this.advSyncReq.interval !== "" ? this.advSyncReq.interval : interval
+			}
+		}
+		//console.error("returning Tweaked interval: " + interval);
+		return interval;
+	},
+	
+	getUTCDateString: function(date){
+		
+		//UTC time format	  
+		var year = date.getUTCFullYear();
+		var month = date.getUTCMonth()+1;
+		var day = date.getUTCDate();
+		var hour= date.getUTCHours();
+		var minute=date.getUTCMinutes();
+		var second =date.getUTCSeconds();
+			
+		month	= (month > 9)	? month		: "0"+month;
+		day		= (day > 9)		? day		: "0"+day;
+		hour	= (hour > 9)	? hour		: "0"+hour;
+		minute	= (minute > 9)	? minute	: "0"+minute;
+		second	= (second > 9)	? second	: "0"+second;
+		
+		//YYYY-MM-DD HH:MM:SSZ
+		return (""+year+"-"+month+"-"+day+" "+hour+":"+minute+":"+second+"Z");  
+	},
+	
+	getNextStart: function(){
+		var nextStart = false;
+		if(this.customSyncSchedule){
+			if(this.advSyncReq.syncallday === false && !isNaN(this.advSyncReq.starttime) && !isNaN(this.advSyncReq.endtime) ){
+				// only do this if we're not doing an initial sync from accounts app
+				if(!(this.client.transport && this.client.transport.initialSync)){
+					var timeMachine = new Date(this.advSyncReq.endtime);
+					var hrs, mins, startTS, stopTS, now = (new Date()).getTime();
+					
+					hrs = timeMachine.getUTCHours();
+					mins = timeMachine.getUTCMinutes();
+					timeMachine.setTime(now);
+					timeMachine.setHours(hrs);
+					timeMachine.setMinutes(mins);
+					stopTS = timeMachine.getTime();
+					timeMachine.setTime(this.advSyncReq.starttime);
+					hrs = timeMachine.getUTCHours();
+					mins = timeMachine.getUTCMinutes();
+					timeMachine.setTime(now);
+					timeMachine.setHours(hrs);
+					timeMachine.setMinutes(mins);
+					startTS = timeMachine.getTime();
+					if(parseInt(this.advSyncReq.endtime,10) <= parseInt(this.advSyncReq.starttime,10)){
+						//start after end, subtract a day from start
+						startTS = startTS - 86400000;
+						timeMachine.setTime(startTS);
+						timeMachine.setHours(hrs);
+						timeMachine.setMinutes(mins);
+						startTS = timeMachine.getTime();
+					}
+					console.error("CustomSyncStart start: " + (timeMachine.setTime(startTS) && timeMachine.toString()) + ", now: " + (timeMachine.setTime(now) && timeMachine.toString()) + ", stop: "+ (timeMachine.setTime(stopTS) && timeMachine.toString()+" "+ this.client.clientId) );
+					if(!(now < stopTS && now >= startTS)){
+						if(now < startTS){
+							timeMachine.setTime(startTS);
+							nextStart = this.getUTCDateString(timeMachine);
+						} else {//next day compensate for daylight savings
+							timeMachine.setTime(startTS + 86400000);
+							timeMachine.setHours(hrs);
+							timeMachine.setMinutes(mins);
+							nextStart = this.getUTCDateString(timeMachine);
+						}
+						if(timeMachine.getTime() < now){
+							// safety check
+							// if scheduled start is before now
+							// it will start immediately, resulting in infinite loop
+							// so add another day
+							var aday = timeMachine.getTime() + 86400000;
+							timeMachine.setTime(aday);
+							timeMachine.setHours(hrs);
+							timeMachine.setMinutes(mins);
+							nextStart = this.getUTCDateString(timeMachine);
+						}
+						console.error("CustomSyncStart schedule starting at: " + nextStart +" "+ this.client.clientId);
+						return nextStart;
+					} else {
+						console.error("CustomSyncStart schedule in sync window continuing sync "+ this.client.clientId);
+					}
+				} else {
+					console.error("CustomSyncStart schedule initial sync in process "+ this.client.clientId);
+				}
+			} else {
+				console.error("CustomSyncStart schedule, bad start and stop times "+ this.client.clientId);
+			}
+		}
+		return nextStart;
+	},
+	
+	getTweakedReqs: function(update){
+		this.customSyncSchedule = false;
+		var req = {};
+		var oldReqs = this.oldReqs;
+		var serviceName = this.controller.service.name;
+		//var defaults = [false /*onoff*/, false /*contacts*/, false /*wifi*/, false /*cell*/, false /*battery*/, "20m" /*0d0h20m0s*/, false/*charging*/, false /*docked*/];
+		if(this.useTweaksReq && this.advSyncReq && this.advSyncReq.onoff === true){
+			if(serviceName.indexOf("calendar") !== -1 || (serviceName.indexOf("contacts") !== -1 && this.advSyncReq.contacts === true) ){
+				// calendars or contacts "on" as well
+				if(this.advSyncReq.syncallday === false && !isNaN(this.advSyncReq.starttime) && !isNaN(this.advSyncReq.endtime) ){
+					this.customSyncSchedule = true;
+				}
+				if(this.advSyncReq.wifi === true && this.advSyncReq.wan === true){
+					//both on, best to remove the requirements as this is AND not an OR
+					if(update && oldReqs && oldReqs.wifi){
+						req.wifi = false;
+					}
+					if(update && oldReqs && oldReqs.wan){
+						req.wan = false;
+					}
+				} else {
+					if(!!this.advSyncReq.wifi){
+						req.wifi = true;
+					} else if(update && oldReqs && oldReqs.wifi){
+						req.wifi = false;
+					}
+					if(!!this.advSyncReq.wan){
+						req.wan = true;
+					} else if(update && oldReqs && oldReqs.wan){
+						req.wan = false;
+					}
+				}
+				if(parseInt(this.advSyncReq.battery, 10) > 0){
+					req.battery = parseInt(this.advSyncReq.battery, 10);
+				} else if(update && oldReqs && oldReqs.battery){
+					req.battery = false;
+				}
+				if(!!this.advSyncReq.charging){
+					req.charging = true;
+				} else if(update && oldReqs && oldReqs.charging){
+					req.charging = false;
+				}
+				if(!!this.advSyncReq.docked){
+					req.docked = true;
+				} else if(update && oldReqs && oldReqs.docked){
+					req.docked = false;
+				}
+			} else if(serviceName.indexOf("contacts") !== -1 && this.advSyncReq.contacts === false){
+				if(update && oldReqs && oldReqs.battery){
+					req.battery = false;
+				}
+				//req.interval = (serviceName.indexOf("facebook") === -1 ? "20m" : "24h");
+				if(update && oldReqs && oldReqs.docked){
+					req.docked = false;
+				}
+				if(update && oldReqs && oldReqs.charging){
+					req.charging = false;
+				}
+				if(update && oldReqs && oldReqs.wan){
+					req.wan = false;
+				}
+				if(update && oldReqs && oldReqs.wifi){
+					req.wifi = false;
+				}
+			}
+		} else {
+			//must set defaults in case it was previously on
+			if(update && oldReqs && oldReqs.battery){
+				req.battery = false;
+			}
+			//req.interval = (serviceName.indexOf("facebook") === -1 ? "20m" : "24h");
+			if(update && oldReqs && oldReqs.docked){
+				req.docked = false;
+			}
+			if(update && oldReqs && oldReqs.charging){
+				req.charging = false;
+			}
+			if(update && oldReqs && oldReqs.wan){
+				req.wan = false;
+			}
+			if(update && oldReqs && oldReqs.wifi){
+				req.wifi = false;
+			}
+		}
+		req.internetConfidence = "fair";
+		
+		return req;
+	},
+	
+	getAdvConfigReq: function () {
+		var timeMachine = new Date(2000, 0, 1, 0, 0, 0, 0);
+		timeMachine.setHours(7);
+		var start = timeMachine.getTime();
+		timeMachine.setHours(18);
+		var end = timeMachine.getTime();
+		var accountId = this.client.clientId,
+		serviceId = this.controller.service.name,
+		serviceAssistant = this.controller.service.assistant,
+		name = this.controller.config.name,
+		map = ["onoff", "contacts","wifi","wan","battery","interval", "charging", "docked", "syncallday", "starttime", "endtime"],
+		defaults = [false /*onoff*/, false /*contacts*/, false /*wifi*/, false /*cell*/, false /*battery*/, "20m" /*0d0h20m0s*/, false/*charging*/, false /*docked*/, true /*all day*/, start, end];
+		
+		this.advSyncReq ={};
+		this.useTweaksReq = false;
+		this.customSyncSchedule = false;
+		
+		if(this.controller.args && this.controller.args.$activity){
+			if(this.controller.args.$activity.trigger &&  this.controller.args.$activity.trigger.returnValue===true){
+				serviceAssistant._EditOnSyncFired[this.client.clientId] = true;
+			} else {
+				serviceAssistant._EditOnSyncFired[this.client.clientId] = false;
+			}
+			if(this.controller.args.$activity.requirements !== undefined){
+				this.oldReqs = this.controller.args.$activity.requirements;
+			} else {
+				this.oldReqs = {};
+			}
+		}
+		if(serviceId.indexOf("facebook") !== -1){
+			defaults[5] = "24h";
+		}
+		
+		var future = new Future();
+		Utils.error("Adv config req start .... " + serviceId + ", name: " +name + ",account: " + accountId);
+		var inner = PalmCall.call("palm://org.webosinternals.tweaks.prefs",
+							"get",
+									{owner: "google-first-sync",
+									keys: ["advancedSyncEnabled", "syncStringField"], subscribe:false}
+		);
+		
+		future.nest(inner).then(this, function gotTweaks(inner) {
+			var reqs = {}, result, exception;
+			
+			Utils.error("in got tweaks synccommand old reqs: " + JSON.stringify(this.oldReqs));
+
+			try{
+				//Utils.error("Get tweaks results????");
+				result = inner.result;
+				exception = inner.exception;
+				//Utils.error("TWEAKS adv req results: " + (result && JSON.stringify(result)) );
+				//Utils.error("TWEAKS call started result: " + JSON.stringify(future.result) );
+				//Utils.error("TWEAKS call exception: " + JSON.stringify(future.exception) );
+				if(result && result.returnValue === true) {
+					this.useTweaksReq = !!result.advancedSyncEnabled;
+					if(result.syncStringField && result.syncStringField !== ""){
+						reqs = JSON.parse(result.syncStringField);
+						for(var prop in reqs){
+							if(reqs.hasOwnProperty(prop) && reqs[prop] !== undefined && accountId === prop){
+								var opt;
+								if(reqs[prop] && reqs[prop].length === defaults.length){
+									for(var i=0;i<defaults.length;i++){
+										opt = reqs[prop][i];
+										if(opt !== undefined && opt !== null && opt !== ""){
+											this.advSyncReq[map[i]] = opt;
+										} else {
+											this.advSyncReq[map[i]] = defaults[i];
+										}
+									}
+								}
+								Utils.error("TWEAKS adv req results: " + prop + ",values: " + JSON.stringify(this.advSyncReq) );
+								break;
+							}
+						}
+						if(this.useTweaksReq && this.advSyncReq && this.advSyncReq.onoff === true){
+							if(serviceId.indexOf("calendar") !== -1 || (serviceId.indexOf("contacts") !== -1 && this.advSyncReq.contacts === true) ){
+								if(this.advSyncReq.syncallday === false && !isNaN(this.advSyncReq.starttime) && !isNaN(this.advSyncReq.endtime) ){
+									this.customSyncSchedule = true;
+								}
+							}
+						}
+					}
+				}
+				
+				inner.result = true;
+				//return (useReq && {useReq: useReq, reqs: reqs});
+			} catch(error) {
+				//Utils.error("in Get tweaks::: error ");
+				console.log("failed to read TWEAKS advanced requirements" + JSON.stringify(error && error.message));
+				inner.result = true;
+			}
+		});
+		return future;
+	},
 
 	initialize: function()
 	{
@@ -141,6 +436,7 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 			capabilityFuture;
 		
 		serviceAssistant._syncInProgress 	= serviceAssistant._syncInProgress || {};
+		serviceAssistant._EditOnSyncFired 	= serviceAssistant._EditOnSyncFired || {};
 
 		// determine if the account capability is enabled for this transport
 		try {
@@ -148,9 +444,16 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 		} catch(e) {
 			console.error("Error fetching capabilityProviderId from client");
 		}
-
+		console.error("sync arguments trigger: "+JSON.stringify((this.controller.args && this.controller.args.$activity)));
+		
 		if (capabilityId) {
-			capabilityFuture = PalmCall.call("palm://com.palm.service.accounts/", "listAccounts", {}); 
+			capabilityFuture = this.getAdvConfigReq();
+			
+			capabilityFuture.then(this, function(){
+				var result = capabilityFuture.result;
+				
+				return PalmCall.call("palm://com.palm.service.accounts/", "listAccounts", {}); 
+			});
 			
 			capabilityFuture.then(this, function(accountDataFuture) {
 				var isEnabled = false,
@@ -175,7 +478,7 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 			});
 		} else {
 			console.error("CapabilityId is empty, allowing sync to continue");
-			capabilityFuture = new Future(true);
+			capabilityFuture = this.getAdvConfigReq(); //new Future(true);
 		}
 
 		capabilityFuture.then(this, function() {
@@ -238,6 +541,7 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 		var details = PalmCall.call("palm://com.palm.activitymanager", "getDetails", {"activityName": name}).then(this, function(future) {
 			// got it - return details
 			future.result = future.result.activity;
+			console.error("Query for 'Periodic Sync' found activity: " +JSON.stringify(future.result.activityId));
 		},
 		function(future) {
 			// error - create activity
@@ -270,6 +574,7 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 				else {
 					interval = future.result;
 				}
+				interval = this.getTweakedInterval(interval);
 				var requiresInternet;
 				var requirements;
 				if (this.client.requiresInternet && typeof this.client.requiresInternet === 'function') {
@@ -285,17 +590,34 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 					console.error("=== Default answer is 'true' - internet is required ===");
 					requiresInternet = true;
 				}
-				requirements = (requiresInternet) ? { internetConfidence: "fair" } : undefined;
+				requirements = this.getTweakedReqs(false);
 				var args = { accountId: this.client.clientId };
-				var activity = new Foundations.Control.Activity(name, "Periodic Sync", true)
-					.setScheduleInterval(interval)
-					.setUserInitiated(false)
-					.setExplicit(true)
-					.setPersist(true)
-					.setReplace(true)
-					.setRequirements(requirements)
-					.setCallback("palm://" + this.controller.service.name + "/"+this.controller.config.name, args);
-				return activity.start();
+				var activityMethod = "create";
+				var activityArgs = {
+					"start": true,
+					"replace": true,
+					"schedule": {"interval": interval},
+					"activity": {
+						"name": name,
+						"description": "Periodic Sync",
+						"type": {
+							"persist": true,
+							"immediate": true,
+							"priority": "low",
+							"explicit":true,
+							"power":true
+						},
+						"requirements": requirements,
+						"callback": {method:"palm://" + this.controller.service.name + "/"+this.controller.config.name, params: args}
+					}
+				};
+				console.error("Find periodic error create act: "+ this.client.clientId + ", requirements: " + JSON.stringify(requirements) +", sched: "+interval);
+				return future.nest(PalmCall.call("palm://com.palm.activitymanager", activityMethod, activityArgs).then(this, function(inner){
+						var result = inner.result;
+						console.error("Find periodic error, create result: " + JSON.stringify(result));
+						return result;
+						})
+					);
 			});
 		});
 		return details;
@@ -328,6 +650,124 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 	complete: function(activity) {
 		console.log("Completing activity "+activity.name);
 		
+		//custom sync logic
+		if(this.customSyncSchedule){
+			var nextStart = this.getNextStart();
+			if(nextStart){
+				var schedule, future = new Future();
+				//we complete whatever just fired, then schedule the Custom sync restart
+				var innerCS = activity.complete().then(this, function(innerCS) {
+							Utils.error("CustomSyncStart previos sync complete succeeded, result = "+ this.client.clientId+" "+JSON.stringify(innerCS.result));
+							innerCS.result=true;
+						},
+						function(innerCS) {
+							//causes bug where database sync types are crossed
+							console.error("CustomSyncStart previos sync FAILED, exception = "+JSON.stringify(innerCS.exception));
+							//ignoring error try to establish database watch
+							innerCS.result=true;
+						}
+					);
+				
+				future.nest(innerCS).then(this, function(future){
+					var r = future.result;
+					schedule = {"start": nextStart};
+					var name = "CustomSyncStart:"+this.controller.service.name + ":" + this.client.clientId; 
+					var requiresInternet;
+					var requirements;
+					
+					if (this.client.requiresInternet && typeof this.client.requiresInternet === 'function') {
+						try {
+							requiresInternet = this.client.requiresInternet();
+						} catch (e) {
+							logError("requiresInternet", e);
+							requiresInternet = true;
+						}
+					} else {
+						console.error("=== No requiresInternet function in client for "+this.controller.service.name +" ===");
+						console.error("=== Default answer is 'true' - internet is required ===");
+						requiresInternet = true;
+					}
+					var getDetailsArgs = {"activityName" : name};
+					var needToRestart, actId, innerCustom = PalmCall.call("palm://com.palm.activitymanager/", "getDetails", getDetailsArgs);
+					
+					future.nest(innerCustom).then(this, function(innerCustom){
+						var result;
+						
+						try{
+							var error = innerCustom.exception;
+							result = innerCustom.result;
+						} catch(e){  console.error("Complete query for CustomSyncStart not found "+ this.client.clientId);}
+						if(result && result.activity && result.returnValue === true){
+							console.error("Complete query for CustomSyncStart found activityId: "+ this.client.clientId +" " +result.activity.activityId);
+							// found the CustomSyncStart, we should complete and restart and update the trigger
+							needToRestart = true;
+							actId = result.activity.activityId;
+						}
+						innerCustom.result = true; 
+					});
+					
+					future.then(this, function(future){
+						try{
+							var result = future.result;
+						}catch(e4){console.error("restarting CustomSyncStart error "+ this.client.clientId);}
+						
+						var serviceAssistant = this.controller.service.assistant;
+						//console.error("In CustomSyncStart serviceAssistant._syncInProgress:"+this.client.clientId+ " , " + serviceAssistant._syncInProgress[this.client.clientId]);
+						
+						requirements = this.getTweakedReqs(!!(needToRestart && actId));
+						var args = { accountId: this.client.clientId };
+						
+						if(needToRestart && actId){
+							var activityMethod = "complete";
+							var activityArgs = {
+								"activityId": actId,
+								"restart": true,
+								"schedule": schedule,
+								"requirements": requirements
+							};
+							console.error("CustomSyncStart restarting, name: "+ name + ", activityArgs: " + JSON.stringify(activityArgs));
+
+							return future.nest(PalmCall.call("palm://com.palm.activitymanager", activityMethod, activityArgs).then(this, function(inner){
+								var result = inner.result;
+								console.error("in Complete, CustomSyncStart restarting result: "+ this.client.clientId+" " + JSON.stringify(result));
+								return result;
+								})
+							);
+							
+						} else {
+							var activityMethod = "create";
+							var activityArgs = {
+								"start": true,
+								"replace": true,
+								"activity": {
+									"name": name,
+									"description": "Custom Sync Start",
+									"type": {
+										"persist": true,
+										"immediate": true,
+										"priority": "low",
+										"power":true
+										//"explicit":true
+									},
+									"schedule": schedule,
+									"requirements": requirements,
+									"callback": {method:"palm://" + this.controller.service.name + "/"+this.controller.config.name, params: args}
+								}
+							};
+							console.error("CustomSyncStart create name: "+ name + ", activityArgs: " + JSON.stringify(activityArgs));
+							return future.nest(PalmCall.call("palm://com.palm.activitymanager", activityMethod, activityArgs).then(this, function(inner){
+								var result = inner.result;
+								console.error("In CustomSyncStart, CustomSyncStart creating result: " + this.client.clientId+" "+ JSON.stringify(result));
+								return result;
+								})
+							);
+						}
+					});
+					this.recreateActivitiesOnComplete = false;
+				});
+				return future;
+			}
+		}
 		// this.recreateActivitiesOnComplete will be set to false when
 		// the sync command is run while the capability is disabled
 		// This is a little messy
@@ -338,29 +778,148 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 			});
 		} else {
 			var syncActivity;
-			
+			var networkError=false;
 			var details = this.getPeriodicSyncActivity().then(this, function(future) {
 				var restart=false;
 				syncActivity = future.result;
 				if (activity._activityId === syncActivity.activityId) {
-					console.log("Periodic sync. Restarting activity");
+					console.log("Periodic sync. Restarting activityId: " + syncActivity.activityId);
 					restart=true;
+					var requirements = this.getTweakedReqs(true);
+					var def = this.controller.service.name.indexOf("facebook") === -1 ? "20m" : "24h";
+					var sched = this.getTweakedInterval(def);
+					//activity.setPower(true);
+					//activity.setScheduleInterval(sched);
+					
 				} else {
-					console.log("Not periodic sync. Completing activity");
+					console.log("Not periodic sync. Completing activity ");
 				}
 				if(this._hadLocalRevisionError) {
 					restart = true;
 					this._hadLocalRevisionError = false;
 				}
-				return activity.complete(restart);
-			}).then(function(future) {
-				Utils.debug("Complete succeeded, result = "+JSON.stringify(future.result));
+				if (this._error && this._error.message && this._error.message.indexOf("httpClient error") != -1) {
+					networkError=true;
+					this.retryNetworkError(activity);
+				}
+				if(restart && syncActivity.activityId && syncActivity.name === this.getPeriodicSyncActivityName() ){
+					if(syncActivity.type && (syncActivity.type.background || !syncActivity.type.power)){
+						//fix to make them immediate, but low priority
+						var inner = activity.complete().then(this, function(inner) {
+									Utils.error("tweak periodic complete succeeded, result = "+ this.client.clientId+" "+JSON.stringify(inner.result));
+									inner.result=true;
+								},
+								function(inner) {
+									//causes bug where database sync types are crossed
+									console.error("tweak periodic FAILED, exception = "+JSON.stringify(inner.exception));
+									//ignoring error try to establish database watch
+									inner.result=true;
+								}
+							);
+						
+						future.nest(inner).then(this, function(future){
+							var r = future.result;
+							var name = this.getPeriodicSyncActivityName();
+							var inner2;
+							if (this.client.getSyncInterval && typeof this.client.getSyncInterval === 'function') {
+								try {
+									inner2 = this.client.getSyncInterval();
+								} catch (e) {
+									logError("getSyncInterval", e);
+									inner2 = new Future("24h");
+								}
+							} else {
+								console.error("=== No getSyncInterval function in client for "+this.controller.service.name +" ===");
+								console.error("=== Default sync interval is 24 hours ===");
+								inner2 = new Future("24h");
+							}
+							future.nest(inner2).then(this, function(future) {
+								//ToDo: merge this with implementation in EnableAccoutCommand
+								var interval;
+								if (future.exception) {
+									console.error("Error in client.getSyncInterval, assuming syncInterval 24h "+ this.client.clientId);
+									interval="24h";
+								} 
+								else {
+									interval = future.result;
+								}
+								interval = this.getTweakedInterval(interval);
+								var requiresInternet;
+								var requirements;
+								if (this.client.requiresInternet && typeof this.client.requiresInternet === 'function') {
+									try {
+										requiresInternet = this.client.requiresInternet();
+									}
+									catch (_) {
+										console.error("client error in requiresInternet");
+										requiresInternet=true;
+									}
+								} else {
+									console.error("=== No requiresInternet function in client for "+this.controller.service.name +" ===");
+									console.error("=== Default answer is 'true' - internet is required ===");
+									requiresInternet = true;
+								}
+								requirements = this.getTweakedReqs(false);
+								var args = { accountId: this.client.clientId };
+								var activityMethod = "create";
+								var activityArgs = {
+									"start": true,
+									"replace": true,
+									"schedule": {"interval": interval},
+									"activity": {
+										"name": name,
+										"description": "Periodic Sync",
+										"type": {
+											"persist": true,
+											"immediate": true,
+											"priority": "low",
+											"explicit":true,
+											"power":true
+										},
+										"requirements": requirements,
+										"callback": {method:"palm://" + this.controller.service.name + "/"+this.controller.config.name, params: args}
+									}
+								};
+								console.error("tweak replacing periodic with act: "+ this.client.clientId + ", requirements: " + JSON.stringify(requirements));
+								return future.nest(PalmCall.call("palm://com.palm.activitymanager", activityMethod, activityArgs).then(this, function(inner3){
+										var result = inner3.result;
+										console.error("tweak periodic, create result: " + this.client.clientId+" "+ JSON.stringify(result));
+										return result;
+										})
+									);
+						
+							});
+							//future.result 
+						});
+					} else {
+						var activityMethod = "complete";
+						var activityArgs = {
+							"activityId": syncActivity.activityId,
+							"restart": true,
+							"schedule": {interval: sched},
+							"requirements": requirements
+						};
+						console.error("Periodic sync. set requirements: " + JSON.stringify(requirements) + ", schedule: " + sched);
+						return future.nest(PalmCall.call("palm://com.palm.activitymanager", activityMethod, activityArgs).then(this, function(inner){
+									var result = inner.result;
+									console.error("Complete periodic sync, restart result: "+ this.client.clientId+" " + JSON.stringify(result));
+									return result;
+									})
+							);
+					}
+				} else {
+					return activity.complete(restart);
+				}
+			}).then(this, function(future) {
+				Utils.debug("Complete succeeded, result = "+ this.client.clientId +" "+JSON.stringify(future.result));
 				future.result=true;
 			},
 			function(future) {
-				console.log("Complete FAILED, exception = "+JSON.stringify(future.exception));
-				future.result=false;
+				console.error("Complete FAILED, exception = "+JSON.stringify(future.exception));
+				//ignoring error try to establish database watch
+				future.result=true;
 			}).then(this, function(future) {
+				
 				if (future.result) {
 					// TODO: Set up one of these for each synced kind...
 					if (this._local2remoteTransformer) { // if we can up-sync, set up a watch to kick of sync on edit
@@ -368,6 +927,7 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 						var name = "SyncOnEdit:"+this.controller.service.name + ":" + this.client.clientId; //TODO: clean this up here and in EnableAccountCommand
 						var requiresInternet;
 						var requirements;
+						//console.error("sync complete results: " + JSON.stringify(future));
 						if (this.client.requiresInternet && typeof this.client.requiresInternet === 'function') {
 							try {
 								requiresInternet = this.client.requiresInternet();
@@ -380,36 +940,156 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 							console.error("=== Default answer is 'true' - internet is required ===");
 							requiresInternet = true;
 						}
-						requirements = (requiresInternet) ? { internetConfidence: "fair" } : undefined;
-						var queryParams = {
-							"query":{
-								"from":this._kind,
-								"where":[
-									{"prop":"accountId", "op":"=", "val":this.client.transport.accountId},
-									{"prop":"_rev", "op":">", "val": rev}
-								],
-								incDel: true
-							},
-							"subscribe": true
-						};
-						var args = { accountId: this.client.clientId };
-						var activity = new Foundations.Control.Activity(name, "Sync On Edit", true)
-							.setUserInitiated(false)
-							.setExplicit(true)
-							.setPersist(true)
-							.setReplace(true)
-							.setRequirements(requirements)
-							.setTrigger("fired", "palm://com.palm.db/watch", queryParams)
-							.setCallback("palm://" + this.controller.service.name + "/"+this.controller.config.name, args);
-						return activity.start();
+						var getDetailsArgs = {"activityName" : name};
+						var needToRestart, actId, inner1 = PalmCall.call("palm://com.palm.activitymanager/", "getDetails", getDetailsArgs);
+						
+						future.nest(inner1).then(this, function(inner1){
+							var result;
+							
+							try{
+								var error = inner1.exception;
+								result = inner1.result;
+							} catch(e){  console.error("Complete query for synconedit not found"+ this.client.clientId);}
+							if(result && result.activity && result.returnValue === true){
+								console.error("Complete query for synconedit found activityId: "+ this.client.clientId +" : " +result.activity.activityId);
+								// found the sync on edit, we should complete and restart and update the trigger
+								needToRestart = true;
+								actId = result.activity.activityId;
+							}
+							inner1.result = true; 
+						});
+						
+						future.then(this, function(future){
+							try{
+								var result = future.result;
+							}catch(e4){console.error("restarting synconedit error"+ this.client.clientId);}
+							
+							var serviceAssistant = this.controller.service.assistant;
+							//console.error("In sync on edit serviceAssistant._syncInProgress:"+this.client.clientId+ " , " + serviceAssistant._syncInProgress[this.client.clientId]);
+							if(!serviceAssistant._syncInProgress[this.client.clientId]){
+								requirements = this.getTweakedReqs(!!(needToRestart && actId));
+								var queryParams = {
+									"query":{
+										"from":this._kind,
+										"where":[
+											{"prop":"accountId", "op":"=", "val":this.client.transport.accountId},
+											{"prop":"_rev", "op":">", "val": rev}
+										],
+										incDel: true
+									},
+									"subscribe": true
+								};
+								var args = { accountId: this.client.clientId };
+								
+								if(needToRestart && actId){
+									var activityMethod = "complete";
+									var activityArgs = {
+										"activityId": actId,
+										"restart": true,
+										"requirements": requirements,
+										"trigger": {"method": "palm://com.palm.db/watch", key:"fired", params: queryParams},
+										
+									};
+									//only here if it was a periodic sync and the sync on edit exists
+									//if there were changes, sync on edit might have already fired
+									//don't complete it if it already fired
+									if(!serviceAssistant._EditOnSyncFired[this.client.clientId]){
+										console.error("DBwatch trigger restarting, rev: " + rev + ", act: "+ this.client.clientId + ", requirements: " + JSON.stringify(requirements));
+										return future.nest(PalmCall.call("palm://com.palm.activitymanager", activityMethod, activityArgs).then(this, function(inner){
+											var result = inner.result;
+											console.error("in Complete, dbwatch restarting result: "+ this.client.clientId+" " + JSON.stringify(result));
+											return result;
+											})
+										);
+									} else {
+										//SyncOnEdit already fired just set good result
+										console.error("second check for SyncOnEdit -- already running "+ this.client.clientId);
+										future.result = true;
+									}
+								} else {
+									var activityMethod = "create";
+									var activityArgs = {
+										"start": true,
+										"replace": true,
+										
+										"activity": {
+											"name": name,
+											"description": "Sync On Edit",
+											"type": {
+												"persist": true,
+												"immediate": true,
+												"priority": "low",
+												"power":true
+												//"explicit":true
+											},
+											"requirements": requirements,
+											"trigger": {"method": "palm://com.palm.db/watch", key:"fired", params: queryParams},
+											"callback": {method:"palm://" + this.controller.service.name + "/"+this.controller.config.name, params: args}
+										}
+									};
+									console.error("DBwatch trigger "+ (activityMethod === "complete"? "restarting" : activityMethod)+", rev: " + rev + ", name: "+ name + ", requirements: " + JSON.stringify(requirements));
+									return future.nest(PalmCall.call("palm://com.palm.activitymanager", activityMethod, activityArgs).then(this, function(inner){
+										var result = inner.result;
+										console.error("In complete, dbwatch creating result: "+ this.client.clientId+" " + JSON.stringify(result));
+										return result;
+										})
+									);
+								}
+							} else {
+								//SyncOnEdit already fired just set good result
+								console.error("In sync on edit restart step, is SyncOnEdit already running "+ this.client.clientId);
+								future.result = true;
+							}
+						});
 					}
 				}
-				future.result=true;
+				return future;
 			});
 			return details;
 		}
 	},
-
+	
+	retryNetworkError: function(activity) {
+		var retryCount=0;
+		console.error("Creating retry activity");
+		// This should really get parsed in at command startup
+		if (this.controller.args.$activity && this.controller.args.$activity.metadata  && this.controller.args.$activity.metadata.retryCount) {
+			retryCount = this.controller.args.$activity.metadata.retryCount;
+			console.error("Retry count is "+retryCount);
+		}
+		if (retryCount < this.getMaxSyncRetries()) {
+			console.error("Network error detected, restarting activity after " + this.getSyncRetryInterval(retryCount));
+			var name = "SyncRetry:"+this.controller.service.name + ":" + this.client.clientId;
+			var requiresInternet;
+			var requirements;
+			if (this.client.requiresInternet && typeof this.client.requiresInternet === 'function') {
+				try {
+					requiresInternet = this.client.requiresInternet();
+				} catch (e) {
+					logError("requiresInternet", e);
+					requiresInternet = true;
+				}
+			} else {
+				console.error("=== No requiresInternet function in client for "+this.controller.service.name +" ===");
+				console.error("=== Default answer is 'true' - internet is required ===");
+				requiresInternet = true;
+			}
+			requirements = this.getTweakedReqs(false);
+			var args = { accountId: this.client.clientId };
+			var retryActivity = new Foundations.Control.Activity(name, "SyncRetry", true)
+				.setUserInitiated(false)
+				.setExplicit(true)
+				.setPersist(true)
+				.setReplace(true)
+				.setRequirements(requirements)
+				.setScheduleInterval(this.getSyncRetryInterval(retryCount))
+				.setMetadata({"retryCount":retryCount+1})
+				.setCallback("palm://" + this.controller.service.name + "/"+this.controller.config.name, args);
+			return retryActivity.start();
+		} else {
+			console.error(">>>Too many retries, giving up for now.");
+		}
+	},
 	__start:
 	{
 		__enter: function()
@@ -623,7 +1303,7 @@ var SyncCommand = exports.SyncCommand = Class.create(Transport.Command,
 			console.log("preSaveModify");
 			// modify local objects before pushing to database
 			try {
-				this.preSaveModify(this._localWriteback).then(this._gotReply);
+				this.preSaveModify(this._localWriteback, this._kindName).then(this._gotReply);
 			} catch (e) {
 				logError("preSaveModifyStep", e);
 				this._error=e;
diff --git a/usr/palm/services/com.palm.service.calendar.google/javascript/assistants/serviceassistant.js b/usr/palm/services/com.palm.service.calendar.google/javascript/assistants/serviceassistant.js
index dca630d..17c2d46 100644
--- a/usr/palm/services/com.palm.service.calendar.google/javascript/assistants/serviceassistant.js
+++ b/usr/palm/services/com.palm.service.calendar.google/javascript/assistants/serviceassistant.js
@@ -28,7 +28,16 @@ var ServiceAssistant = Transport.ServiceAssistantBuilder({
 		},
 
 		setup: function setup(service, accountId, launchConfig, launchArgs) {
-			var future = this._getAccount(accountId);
+			
+			//var future = new Future(true);// = this._getAccount(accountId);
+
+			Config.syncWindowMonthsAfter = 48; 
+			Config.syncWindowMonthsBefore = 12;
+			Config.syncChangesOnly = false;
+			
+			var future = this._goTweaks(accountId);
+			
+			//Utils.error("google sync start preferences: " + stringify(Config.syncWindowMonthsBefore) +": " +stringify(Config.syncWindowMonthsAfter) );
 			
 			future.then(this, function finishSetup() {
 				var account = future.result,
@@ -84,6 +93,57 @@ var ServiceAssistant = Transport.ServiceAssistantBuilder({
 			
 			return future;
 		},
+		
+		_goTweaks: function(Id){
+			//Utils.error("in Get tweaks ");
+			var future = PalmCall.call("palm://org.webosinternals.tweaks.prefs",
+							"get",
+									{owner: "google-first-sync",
+									keys: ["syncWindowMonthsBefore", "syncWindowMonthsAfter", "syncStrategy"], subscribe:false}
+							);
+		
+			future.then(this, function readTweaks() {
+				//Utils.error("in Read tweaks ");
+				var result;
+				try{
+					//Utils.error("Get tweaks results????");
+					result = future.result;
+					Utils.error("TWEAKS call started: " + stringify(Config.syncWindowMonthsBefore) +": " +stringify(Config.syncWindowMonthsAfter) );
+					//Utils.error("TWEAKS call started result: " + stringify(future.result) );
+					//Utils.error("TWEAKS call exception: " + stringify(future.exception) );
+					if(result && result.returnValue === true) {
+						if(result.syncWindowMonthsBefore && parseInt(result.syncWindowMonthsBefore,10) >= 1 && parseInt(result.syncWindowMonthsBefore,10) <= 60) {
+							Utils.error("TWEAKS preference: before sync = " + result.syncWindowMonthsBefore);
+							Config.syncWindowMonthsBefore = parseInt(result.syncWindowMonthsBefore,10);
+						}
+						if(result.syncWindowMonthsAfter && parseInt(result.syncWindowMonthsAfter,10) >= 2 && parseInt(result.syncWindowMonthsAfter,10) <= 60) {
+							Utils.error("TWEAKS preference: after sync = " + result.syncWindowMonthsAfter);
+							Config.syncWindowMonthsAfter = parseInt(result.syncWindowMonthsAfter,10);
+						}
+						if(result.syncStrategy && result.syncStrategy === "changesonly"){
+							Utils.error("TWEAKS preference: sync strategy = " + result.syncStrategy);
+							Config.syncChangesOnly = true;
+						} else {
+							Utils.error("TWEAKS preference:  sync strategy = default");
+							Config.syncChangesOnly = false;
+						}
+					}
+					future.result= true;
+				} catch(error) {
+					//Utils.error("in Get tweaks::: error ");
+					Utils.error("failed to read TWEAKS preferences no result" + stringify(error && error.message));
+				}
+				future.result= true;
+			});
+			
+			future.then(this, function(){
+				var result = future.result;
+				//Utils.error("in Get tweaks::: then again ");
+				return this._getAccount(Id);
+			});
+			
+			return future;
+		},
 
 		_getAccount: function (id) {
 			var future = DB.find({
diff --git a/usr/palm/services/com.palm.service.calendar.google/javascript/assistants/syncassistant.js b/usr/palm/services/com.palm.service.calendar.google/javascript/assistants/syncassistant.js
index 2f691e7..eea7c85 100644
--- a/usr/palm/services/com.palm.service.calendar.google/javascript/assistants/syncassistant.js
+++ b/usr/palm/services/com.palm.service.calendar.google/javascript/assistants/syncassistant.js
@@ -98,12 +98,14 @@ var SyncAssistant = Class.create(Sync.SyncCommand, {
 			if (transform) {
 				transformer = new Json.Transformer(transform);
 				return function (to, from) {
-					Utils.log("\n-->> Transforming " + (from.title && from.title.$t) + " (" + to.accountId + ") " + " (" + direction + ")");
+					Utils.debug("\n-->> Transforming " + (from.title && from.title.$t) + " (" + to.description + ") " + " (" + direction + ")");
 					// Utils.log("\n-->> To: " + stringify(to));
 					// Utils.log("\n-->> From: " + stringify(from));
 					// Utils.log("\n-->> Transform: " + stringify(transform));
 					from.to = to;
 					var t = transformer.transformAndMerge(to, from);
+					Utils.debug("\n-->> Transforming t:" + stringify(t));
+					Utils.debug("\n-->> Transforming t.rrule:" + (t ? stringify(t.rrule) : t));
 					Utils.debug("\n-->> Transformed " + (from.title && from.title.$t)); // + ": " + stringify(t));
 					return t;
 				};
@@ -225,6 +227,18 @@ var SyncAssistant = Class.create(Sync.SyncCommand, {
 		}
 	},
 
+	preSaveModify: function (events, kindName) {
+		if(kindName===Kinds.objects.calendarevent.name) {
+			for(var idx=events.length-1; idx>=0; idx--) {
+				if(!events[idx] ||!events[idx].local ||!events[idx].local.dtstart || !events[idx].local.dtend) {
+					Utils.log("skipping invalid event!");
+					events.splice(idx, 1);
+				}
+			}
+		}
+		return new Future (events);
+	},
+		
 	/*
 	 * Put a set of remote objects to the server.  Each object has an operation property
 	 * which is either 'save' or 'delete', depending on how the objects should be put
@@ -475,8 +489,9 @@ var SyncAssistant = Class.create(Sync.SyncCommand, {
 					if (lEvent.etag === rEvent.getEtag()) {
 						// The ETAG hasn't changed, so we don't want to down-sync
 						// the event.
+						Utils.debug(">>> _filterRemoteEventChangeList(): skipping down-sync for " + (lEvent.description || rEvent.title && rEvent.title.$t));
 						ridMap[lEvent.remoteId] = undefined;
-						Utils.debug(">>> _filterRemoteEventChangeList(): skipping down-sync for " + lEvent.remoteId);
+						
 					} else if (this.isDeleted(rEvent, Kinds.objects.calendarevent.name) && lEvent.exdates && lEvent.exdates.length) {
 						// This is a parent event being deleted; we need to generate
 						// deletion entries for each of the children
@@ -936,7 +951,7 @@ var SyncAssistant = Class.create(Sync.SyncCommand, {
 							remoteCalendarEvent: calendarEventEntry
 						};
 					}), mapFuture.callback(that, function (error) {
-						if (error.cause.status === 404) {
+						if (error && error.cause && error.cause.status === 404) {
 							// Get the local event
 							return DB.find({
 								from: Kinds.objects.calendarevent.id,
@@ -1030,7 +1045,7 @@ var SyncAssistant = Class.create(Sync.SyncCommand, {
 
 		for (i = 0; i < eventsToShift.length; ++i) {
 			event = eventsToShift[i].local;
-			timezoneIds.push(event.tzId);
+			if(event.tzId && event.tzId != undefined ){timezoneIds.push(event.tzId);}
 			date.setTime(event.dtstart);
 			timezoneYears.push(date.getFullYear());
 			date.setTime(event.dtend);
@@ -1393,5 +1408,75 @@ var SyncAssistant = Class.create(Sync.SyncCommand, {
 		}
 
 		return false;
+	},
+		
+	/*
+	 * If we receive a revision error while saving the objects then update the 
+	 * revision number on them
+	 */
+	updateTransportObjectsToLatestRevisionNumber: function(objs, object_kind){
+		var revisionFuture = this.getLatestRevForObjects(objs, object_kind),
+			resulting = [];
+		revisionFuture.then(this, function(rFuture) {
+			var result = rFuture.getResult();
+			if( result && result.length && result.length>0) {
+				rFuture.result.forEach(function(result) {
+					if(result._id) {
+						objs.forEach(function(obj) {
+							if(obj._id===result._id) {
+								// Revisions differ - we made an editlocally while
+								// the sync was running so store remoteId and etag 
+								// from the current object and the object from the
+								// database to the result
+								if(obj._rev!==result._rev) {
+									result.remoteId = obj.remoteId;
+									result.etag = obj.etag;
+									//obj = result;
+									resulting.push(result);
+								} else {
+									resulting.push(obj);
+								}
+							}
+						});
+					}
+				});
+
+				rFuture.result = resulting;
+			} else {
+				rFuture.result = [];
+			} 
+		});
+		return revisionFuture;
+	},
+	
+	updateLocalTransportRevision: function(batchTransport, kindName)
+	{
+		var kinds = this.handler.getObjectKinds(),
+			future = this.updateTransportObjectsToLatestRevisionNumber(batchTransport, kinds.objects[kindName].id);
+		
+		future.then(this, function(join)
+		{
+			try
+			{
+				// copy any changed revs from the input into the local objects
+				var results = join.result,
+				len = results.length;
+				if(len>0) {
+					this._batch.transport = results;
+					this._hadLocalRevisionError = true;
+					this._batch.revisionChangedError = true;
+					return "writeRemoteTransportChanges";
+				} else {
+					throw new Error('Yahoo Transport updateLocalRevision: no data received');
+				}
+			} catch(_) {
+				console.log(_.stack);
+				this._error = _;
+				// Did we previously throw an exception ... if no then throw it
+				return "error";
+			}
+		});
+		
+		return future;
 	}
 });
diff --git a/usr/palm/services/com.palm.service.calendar.google/javascript/models/calendar_event_query.js b/usr/palm/services/com.palm.service.calendar.google/javascript/models/calendar_event_query.js
index a36dbba..c56929c 100644
--- a/usr/palm/services/com.palm.service.calendar.google/javascript/models/calendar_event_query.js
+++ b/usr/palm/services/com.palm.service.calendar.google/javascript/models/calendar_event_query.js
@@ -44,8 +44,10 @@ var CalendarEventQuery = function CalendarEventQuery(gdataService, calendar, syn
 		syncKey.calendar[calUID] = syncKey.calendar[calUID] || {};
 
 		if (time) {
-			time = time.getDate();
-
+			Utils.debug("time: " + typeof(time) + ": " + JSON.stringify(time));
+			if(typeof(time) == 'string') { time = Calendar.IO.Utils.dateFromIso8601(time);} else {
+				time = time.getDate();
+			}
 			logTime("google", Calendar.IO.Utils.dateToIso8601(time));
 
 			if (update) {
@@ -85,10 +87,10 @@ var CalendarEventQuery = function CalendarEventQuery(gdataService, calendar, syn
 			feedEntries[i].tzId = feedRoot.feed.gCal$timezone;
 			feedEntries[i].calendarId = calendar._id;
 			if (feedEntries[i].getOriginalEvent()) {
-				Utils.debug("\n\n---->>>> Found modifying entry (" + i + "): " + feedEntries[i].getTitle().getText());
+				Utils.error("\n\n---->>>> Found modifying entry (" + i + "): " + feedEntries[i].getTitle().getText());
 				modifyingEntries.push(feedEntries[i]);
 			} else {
-				Utils.debug("\n\n---->>>> Entry " + i + ": " + feedEntries[i].getTitle().getText() + " (" + feedEntries[i].calendarId + ")");
+				Utils.error("\n\n---->>>> Entry " + i + ": " + feedEntries[i].getTitle().getText() + " (" + feedEntries[i].calendarId + ")");
 				entries.push(feedEntries[i]);
 			}
 		}
@@ -127,18 +129,30 @@ var CalendarEventQuery = function CalendarEventQuery(gdataService, calendar, syn
 			query.setUpdatedMin(startDate);
 			query.setUpdatedMax(endDate);
 
-			Utils.debug("---->>>> Update window for calendar '" + calendar.name + "' from " + startDate.getDate() + " to " + endDate.getDate());
+			//Utils.error("---->>>> Update window for calendar '" + calendar.name + "' from " + startDate.getDate() + " to " + endDate.getDate());
 		} else {
+			//Utils.error("TWEAKS preferences applied: " + stringify(Config.syncWindowMonthsBefore) +": " +stringify(Config.syncWindowMonthsAfter) );
 			if (lastModTime) {
 				startDate = google.gdata.DateTime.fromIso8601(lastModTime);
 			} else {
 				startDate = new Date(now);
-				startDate.setMonth(startDate.getMonth() - Config.syncWindowMonthsBefore);
+				if(!!(getLastModifiedTimeForCalendar(true)) && Config.syncChangesOnly){
+					//if not first sync and not default sync strategy 7 days into past
+					startDate.setTime(startDate.getTime() - 604800);
+				} else {
+					startDate.setMonth(startDate.getMonth() - Config.syncWindowMonthsBefore);
+				}
 				startDate = new google.gdata.DateTime(startDate);
 			}
 
 			endDate = new Date(now);
-			endDate.setMonth(endDate.getMonth() + Config.syncWindowMonthsAfter);
+			if(!!(getLastModifiedTimeForCalendar(true)) && Config.syncChangesOnly){
+				//if not first sync and not default sync strategy 14 days forward
+				endDate.setTime(endDate.getTime() + 1209600);
+			} else {
+				endDate.setMonth(endDate.getMonth() + Config.syncWindowMonthsAfter);
+			}
+			//endDate.setMonth(endDate.getMonth() + Config.syncWindowMonthsAfter);
 			endDate = new google.gdata.DateTime(endDate);
 
 			query.setMinimumStartTime(startDate);
@@ -147,7 +161,7 @@ var CalendarEventQuery = function CalendarEventQuery(gdataService, calendar, syn
 			query.setUpdatedMin(undefined);
 			query.setUpdatedMax(undefined);
 
-			Utils.debug("---->>>> Sync window for calendar '" + calendar.name + "' from " + startDate.getDate() + " to " + endDate.getDate());
+			Utils.error("---->>>> Sync window for calendar '" + calendar.name + "' from " + startDate.getDate() + " to " + endDate.getDate());
 		}
 	}
 
@@ -226,9 +240,14 @@ var CalendarEventQuery = function CalendarEventQuery(gdataService, calendar, syn
 						setLastModifiedTimeForCalendar(update, queryResult.modTime);
 						// We just wrapped up an update query; now we'll do
 						// a fetch
-						update = false;
-						startIndex = 1;
-						join.result = true;
+						if(Config.syncChangesOnly && !queryResult.error){
+							Utils.error("TWEAKS sync strategy = changes only no updates, skipping fetch");
+							join.result = false;
+						} else {
+							update = false;
+							startIndex = 1;
+							join.result = true;
+						}
 					} else {
 						if (!getLastModifiedTimeForCalendar(true)) {
 							// If this is the first sync, there'll be no stored
@@ -238,7 +257,7 @@ var CalendarEventQuery = function CalendarEventQuery(gdataService, calendar, syn
 						if (!queryResult.error) {
 							// If the fetch didn't succeed, leave the existing fetch time to use next
 							// sync so we don't end up skipping events
-							setLastModifiedTimeForCalendar(false, query.getMaximumStartTime());
+							setLastModifiedTimeForCalendar(false, queryResult.modTime);
 						}
 						join.result = false;
 					}
diff --git a/usr/palm/services/com.palm.service.calendar.google/javascript/models/eventfamilies.js b/usr/palm/services/com.palm.service.calendar.google/javascript/models/eventfamilies.js
index 3d1cfde..2d2cba0 100644
--- a/usr/palm/services/com.palm.service.calendar.google/javascript/models/eventfamilies.js
+++ b/usr/palm/services/com.palm.service.calendar.google/javascript/models/eventfamilies.js
@@ -241,6 +241,7 @@ function makeOriginalEvent(date, parent) {
 	if (typeof date === 'string') {
 		date = Utils.convertIso8601ToGoogleIso8601(date);
 		date = google.gdata.DateTime.fromIso8601(date);
+		date.setDateOnly(parent.allDay);
 	}
 	originalEvent.setOriginalStartTime({startTime: date});
 
diff --git a/usr/palm/services/com.palm.service.calendar.google/javascript/models/google_calendar_transformer.js b/usr/palm/services/com.palm.service.calendar.google/javascript/models/google_calendar_transformer.js
index 4f28b56..0494efb 100644
--- a/usr/palm/services/com.palm.service.calendar.google/javascript/models/google_calendar_transformer.js
+++ b/usr/palm/services/com.palm.service.calendar.google/javascript/models/google_calendar_transformer.js
@@ -150,7 +150,7 @@ var GoogleCalendarEventTransformer = Class.create({
 			// NOTE: The Google calendar server's XML parser gets very unhappy (400 error)
 			// if there are consecutive whitespace characters (except, for some reason,
 			// new-lines) in certain places.  "Where" is one of them.
-			valueString: GoogleCalendarEventTransformer.collapseWhitespace(from.location),
+			valueString: (from.location != undefined ? GoogleCalendarEventTransformer.collapseWhitespace(from.location) : undefined),
 			rel: google.gdata.Where.REL_EVENT
 		});
 		to.setLocations([location]);
@@ -229,32 +229,35 @@ var GoogleCalendarEventTransformer = Class.create({
 			participant,
 			participants = [],
 			attendeeStatus;
-		for (i = 0; i < from.length; ++i) {
-			participant = new google.gdata.Attendee();
-			participant.setRel(from.organizer ? google.gdata.Who.REL_ORGANIZER : google.gdata.Who.REL_ATTENDEE);
+		for (i = 0; i < from.attendees.length; ++i) {
+			participant = new google.gdata.Who();
+			participant.setRel(from.attendees[i].organizer ? google.gdata.Who.REL_EVENT_ORGANIZER : google.gdata.Who.REL_EVENT_ATTENDEE);
 
 			attendeeStatus = undefined;
-			if (from.participationStatus === "ACCEPTED") {
+			if (from.attendees[i].participationStatus && from.attendees[i].participationStatus === "ACCEPTED") {
 				attendeeStatus = new google.gdata.AttendeeStatus();
 				attendeeStatus.setValue(google.gdata.AttendeeStatus.VALUE_ACCEPTED);
-			} else if (from.participationStatus === "DECLINED") {
+			} else if (from.attendees[i].participationStatus && from.attendees[i].participationStatus === "DECLINED") {
 				attendeeStatus = new google.gdata.AttendeeStatus();
 				attendeeStatus.setValue(google.gdata.AttendeeStatus.VALUE_DECLINED);
-			} else if (from.participationStatus === "TENTATIVE") {
+			} else if (from.attendees[i].participationStatus && from.attendees[i].participationStatus === "TENTATIVE") {
 				attendeeStatus = new google.gdata.AttendeeStatus();
 				attendeeStatus.setValue(google.gdata.AttendeeStatus.VALUE_TENTATIVE);
+			} else if (from.attendees[i].participationStatus === "NEEDS-ACTION" && from.attendees[i].organizer) {
+				to.setSendEventNotifications({value: true});
+				if(from.attendees.length > 1){Utils.error("\n\n---->>>> attendees Google calendar event: " + (from.attendees && stringify(from.attendees)));}
 			}
 			if (attendeeStatus) {
 				participant.setAttendeeStatus(attendeeStatus);
 			}
-
-			participant.setEmail(from.email);
-			participant.setValueString(from.commonName);
+			participant.setEmail(from.attendees[i].email);
+			participant.setValueString(from.attendees[i].commonName);
 			participants.push(participant);
 		}
 
 		if (participants.length) {
 			to.setParticipants(participants);
+			//Utils.error("\n\n---->>>> Setting participant on Google calendar event: " + participants.length);
 		}
 	},
 
@@ -606,5 +609,9 @@ GoogleCalendarEventTransformer.dayHash = [
 GoogleCalendarEventTransformer.collapseWhitespaceRegex = new RegExp("[\\f\\r\\t \u000B\u00A0\u2028\u2029]{2,}", 'g');
 
 GoogleCalendarEventTransformer.collapseWhitespace = function (str) {
-	return str && str.replace(/\r\n/g, '\n').replace(GoogleCalendarEventTransformer.collapseWhitespaceRegex, ' ');
+	str.replace(/\r\n/g, '\n').replace(GoogleCalendarEventTransformer.collapseWhitespaceRegex, ' ');
+	
+	var escString = str.replace(/(\\)/g,"\\\\");
+	escString.replace(/(,)/g, "\,");
+	return escString.replace(/(")/g, "\"");
 };
diff --git a/usr/palm/services/com.palm.service.calendar.google/javascript/models/transforms.js b/usr/palm/services/com.palm.service.calendar.google/javascript/models/transforms.js
index f97c32d..e572685 100644
--- a/usr/palm/services/com.palm.service.calendar.google/javascript/models/transforms.js
+++ b/usr/palm/services/com.palm.service.calendar.google/javascript/models/transforms.js
@@ -167,11 +167,11 @@ function transformAttendee(participant) {
 
 	attendeeStatus = attendeeStatus && attendeeStatus.getValue();
 	if (attendeeStatus === google.gdata.AttendeeStatus.VALUE_ACCEPTED) {
-		attendee.participantStatus = "ACCEPTED";
+		attendee.participationStatus = "ACCEPTED";
 	} else if (attendeeStatus === google.gdata.AttendeeStatus.VALUE_DECLINED) {
-		attendee.participantStatus = "DECLINED";
+		attendee.participationStatus = "DECLINED";
 	} else if (attendeeStatus === google.gdata.AttendeeStatus.VALUE_TENTATIVE) {
-		attendee.participantStatus = "TENTATIVE";
+		attendee.participationStatus = "TENTATIVE";
 	}
 
 	attendee.email = attendeeEmail;
@@ -243,7 +243,7 @@ Transforms = {
 				
 				var recurrence = from.parsedRecurrence || Transforms.parseRecurrence(from);
 				if (recurrence) {
-					// Utils.log("\n\n---->>>> transformed rrule: " + stringify(recurrence));
+					 Utils.debug("\n\n---->>>> transformed rrule: " + stringify(recurrence));
 					Utils.debug("\n\n---->>>> Recurrence exceptions: " + stringify(from.getRecurrenceException()));
 				}
 
@@ -258,7 +258,7 @@ Transforms = {
 				//    when the user remove the recurrence from server).
 				
 				if(recurrence && recurrence.rrule) {
-					Utils.debug("\n\n---->>>> has rrule");
+					Utils.debug("\n\n---->>>> has rrule: " + stringify(recurrence.rrule));
 					return (recurrence && recurrence.rrule)
 				} else if (from.exdates && from.exdates.length) {
 					Utils.debug("\n\n---->>>> undefined rrule, use existing rrule");
diff --git a/usr/palm/services/com.palm.service.calendar.google/javascript/utils/utils.js b/usr/palm/services/com.palm.service.calendar.google/javascript/utils/utils.js
index 77da023..6c39d6b 100644
--- a/usr/palm/services/com.palm.service.calendar.google/javascript/utils/utils.js
+++ b/usr/palm/services/com.palm.service.calendar.google/javascript/utils/utils.js
@@ -4,6 +4,16 @@ newcap: true, nomen: false, onevar: true, regexp: true, undef: true, white: fals
 /*global _, Calendar, Config, Future, google, mapReduce, stringify, Transport */
 
 var Utils = {
+	
+	//Regexp special characters - need to be escaped within the string the regexp is applied on
+	special : new RegExp(
+        '(\\' + [
+					'/', '.', '*', '+', '?', '|',
+		            '(', ')', '[', ']', '{', '}', '\\',
+		            ',', '.', '#', '$', '-', '^'
+		           ].join('|\\') + ')', 'g'
+	      ),
+	  
 	convertError: function (error) {
 		switch (error && error.cause && error.cause.status) {
 		case 400:
@@ -96,16 +106,22 @@ var Utils = {
 	cacheAuthToken: function (authToken) {
 		if (authToken && authToken !== '') {
 			// console.log("###### cached authToken: " + authToken);
-			Utils.authTokenRegex = new RegExp(authToken, 'g');
+			Utils.authTokenRegex = new RegExp(Utils.replaceRegexSpecialChars(authToken), 'g');
 		}
 	},
 
+	
+	//Escape regexp special characters from the string	 
+	replaceRegexSpecialChars: function(reStr) {	
+		return reStr.replace(Utils.special, '\\$1');	
+	},
+	
 	cachePassword: function (password) {
 		var reStr;
 		if (password && password !== '') {
 			// console.log("###### cached password: " + password);
 			//put the URI encoded password also into the regular expression 
-			reStr = password + "|" + encodeURIComponent(password);
+			reStr = Utils.replaceRegexSpecialChars(password)+ "|" + Utils.replaceRegexSpecialChars(encodeURIComponent(password));
 			Utils.passwordRegex = new RegExp(reStr, 'g');
 		}
 	},
@@ -117,7 +133,7 @@ var Utils = {
 				username = username.slice(0, pos);
 			}
 			// console.log("###### cached username: " + username);
-			Utils.usernameRegex = new RegExp(username, 'g');
+			Utils.usernameRegex = new RegExp(Utils.replaceRegexSpecialChars(username), 'g');
 		}
 	},
 
diff --git a/usr/palm/services/com.palm.service.calendar.google/javascript/utils/xhr.js b/usr/palm/services/com.palm.service.calendar.google/javascript/utils/xhr.js
index 1d5adac..4c548ca 100644
--- a/usr/palm/services/com.palm.service.calendar.google/javascript/utils/xhr.js
+++ b/usr/palm/services/com.palm.service.calendar.google/javascript/utils/xhr.js
@@ -61,7 +61,7 @@ var XMLHttpRequest = Class.create({
 				/*jslint eqeqeq: true */
 				Utils.log("\n\n\n--->>> send called. post body: " + postBody + "");
 				Utils.log("--->>> method: " + this.httpMethod + ", url: " + this.url + ", options: " + stringify(this.options));
-				Utils.log("\n\n\n--->>> status: " + this.result.status);
+				Utils.error("\n\n\n--->>> status: " + this.result.status);
 				Utils.debug("\n--->>> responseText: " + this.result.responseText + " \n");
 				Utils.debug("\n--->>> responseJSON: " + this.result.responseJSON + " \n");
 				Utils.debug("\n--->>> response headers: " + stringify(this.result.getAllResponseHeaders()));
